"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const csso_webpack_plugin_1 = require("csso-webpack-plugin");
const HtmlWebpackIncludeAssetsPlugin = require("html-webpack-include-assets-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const lodash_1 = require("lodash");
const fp_1 = require("lodash/fp");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const path = require("path");
const UglifyJsPlugin = require("uglifyjs-webpack-plugin");
const webpack = require("webpack");
const _1 = require(".");
const postcss_conf_1 = require("../config/postcss.conf");
const defaultUglifyJsOption = {
    keep_fnames: true,
    output: {
        comments: false,
        keep_quoted_props: true,
        quote_keys: true,
        beautify: false
    },
    warnings: false
};
const defaultCSSCompressOption = {
    mergeRules: false,
    mergeIdents: false,
    reduceIdents: false,
    discardUnused: false,
    minifySelectors: false
};
const defaultBabelLoaderOption = {
    plugins: [
        require.resolve('babel-plugin-syntax-dynamic-import'),
        [
            require.resolve('babel-plugin-transform-react-jsx'),
            {
                pragma: 'Nerv.createElement'
            }
        ]
    ]
};
exports.defaultBabelLoaderOption = defaultBabelLoaderOption;
const defaultMediaUrlLoaderOption = {
    limit: 10240
};
exports.defaultMediaUrlLoaderOption = defaultMediaUrlLoaderOption;
const defaultFontUrlLoaderOption = {
    limit: 10240
};
exports.defaultFontUrlLoaderOption = defaultFontUrlLoaderOption;
const defaultImageUrlLoaderOption = {
    limit: 10240
};
exports.defaultImageUrlLoaderOption = defaultImageUrlLoaderOption;
const getLoader = (loaderName, options) => {
    return {
        loader: require.resolve(loaderName),
        options: options || {}
    };
};
const toArray = arg => [arg];
const getPlugin = (plugin, args) => {
    return {
        plugin,
        args
    };
};
const mergeOption = ([...options]) => {
    return _1.recursiveMerge({}, ...options);
};
const getDllContext = (outputRoot, dllDirectory) => {
    return path.join(_1.appPath, outputRoot, dllDirectory);
};
const getNamedDllContext = (outputRoot, dllDirectory, name) => {
    return {
        context: path.join(_1.appPath, outputRoot, dllDirectory),
        name
    };
};
const processDllOption = context => {
    return {
        path: path.join(context, '[name]-manifest.json'),
        name: '[name]_library',
        context
    };
};
const processDllReferenceOption = ({ context, name }) => {
    return {
        context,
        manifest: path.join(context, `${name}-manifest.json`)
    };
};
const processEnvOption = lodash_1.partial(fp_1.mapKeys, key => `process.env.${key}`);
exports.processEnvOption = processEnvOption;
const getStyleLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'style-loader'));
exports.getStyleLoader = getStyleLoader;
const getCssLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'css-loader'));
exports.getCssLoader = getCssLoader;
const getPostcssLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'postcss-loader'));
exports.getPostcssLoader = getPostcssLoader;
const getResolveUrlLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'resolve-url-loader'));
exports.getResolveUrlLoader = getResolveUrlLoader;
const getSassLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'sass-loader'));
exports.getSassLoader = getSassLoader;
const getLessLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'less-loader'));
exports.getLessLoader = getLessLoader;
const getStylusLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'stylus-loader'));
exports.getStylusLoader = getStylusLoader;
const getBabelLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'babel-loader'));
exports.getBabelLoader = getBabelLoader;
const getUrlLoader = fp_1.pipe(mergeOption, lodash_1.partial(getLoader, 'url-loader'));
exports.getUrlLoader = getUrlLoader;
const getExtractCssLoader = () => {
    return {
        loader: MiniCssExtractPlugin.loader
    };
};
exports.getExtractCssLoader = getExtractCssLoader;
const getMiniCssExtractPlugin = fp_1.pipe(mergeOption, toArray, lodash_1.partial(getPlugin, MiniCssExtractPlugin));
exports.getMiniCssExtractPlugin = getMiniCssExtractPlugin;
const getHtmlWebpackPlugin = fp_1.pipe(mergeOption, toArray, lodash_1.partial(getPlugin, HtmlWebpackPlugin));
exports.getHtmlWebpackPlugin = getHtmlWebpackPlugin;
const getDefinePlugin = fp_1.pipe(mergeOption, toArray, lodash_1.partial(getPlugin, webpack.DefinePlugin));
exports.getDefinePlugin = getDefinePlugin;
const getHotModuleReplacementPlugin = lodash_1.partial(getPlugin, webpack.HotModuleReplacementPlugin, []);
exports.getHotModuleReplacementPlugin = getHotModuleReplacementPlugin;
const getUglifyPlugin = ([enableSourceMap, uglifyOptions]) => {
    return new UglifyJsPlugin({
        cache: true,
        parallel: true,
        sourceMap: enableSourceMap,
        uglifyOptions: _1.recursiveMerge({}, defaultUglifyJsOption, uglifyOptions)
    });
};
exports.getUglifyPlugin = getUglifyPlugin;
const getCssoWebpackPlugin = ([cssoOption]) => {
    return fp_1.pipe(mergeOption, toArray, lodash_1.partial(getPlugin, csso_webpack_plugin_1.default))([defaultCSSCompressOption, cssoOption]);
};
exports.getCssoWebpackPlugin = getCssoWebpackPlugin;
const getDllPlugin = fp_1.pipe(getDllContext, processDllOption, toArray, lodash_1.partial(getPlugin, webpack.DllPlugin));
exports.getDllPlugin = getDllPlugin;
const getDllReferencePlugin = fp_1.pipe(getNamedDllContext, processDllReferenceOption, toArray, lodash_1.partial(getPlugin, webpack.DllReferencePlugin));
const getHtmlWebpackIncludeAssetsPlugin = fp_1.pipe(toArray, lodash_1.partial(getPlugin, HtmlWebpackIncludeAssetsPlugin));
exports.getHtmlWebpackIncludeAssetsPlugin = getHtmlWebpackIncludeAssetsPlugin;
const getEntry = (customEntry = {}) => {
    return Object.assign({
        app: path.join('.temp', 'app.js')
    }, customEntry);
};
exports.getEntry = getEntry;
const getModule = ({ staticDirectory, designWidth, deviceRatio, enableExtract, enableSourceMap, styleLoaderOption, cssLoaderOption, lessLoaderOption, sassLoaderOption, stylusLoaderOption, fontUrlLoaderOption, imageUrlLoaderOption, mediaUrlLoaderOption, esnextModules = [], module, plugins }) => {
    const postcssOption = module.postcss || {};
    const styleLoader = getStyleLoader([{ sourceMap: enableSourceMap }, styleLoaderOption]);
    const extractCssLoader = getExtractCssLoader();
    const lastCssLoader = enableExtract ? extractCssLoader : styleLoader;
    const cssOptions = [
        {
            importLoaders: 1,
            sourceMap: enableSourceMap,
            modules: postcssOption.cssModules && postcssOption.cssModules.enable
        },
        cssLoaderOption
    ];
    /**
     * css-loader 1.0.0版本移除了minimize选项...升级需谨慎
     *
     * https://github.com/webpack-contrib/css-loader/releases/tag/v1.0.0
     */
    const cssLoader = getCssLoader(cssOptions);
    const postcssLoader = getPostcssLoader([
        { sourceMap: enableSourceMap },
        {
            ident: 'postcss',
            plugins: postcss_conf_1.getPostcssPlugins({
                designWidth,
                deviceRatio,
                postcssOption
            })
        }
    ]);
    const resolveUrlLoader = getResolveUrlLoader([]);
    const sassLoader = getSassLoader([{ sourceMap: true }, sassLoaderOption]);
    const lessLoader = getLessLoader([{ sourceMap: enableSourceMap }, lessLoaderOption]);
    const stylusLoader = getStylusLoader([{ sourceMap: enableSourceMap }, stylusLoaderOption]);
    const rule = {};
    rule.jsx = {
        use: {
            babelLoader: {
                options: Object.assign({}, plugins.babel, { sourceMap: enableSourceMap })
            }
        }
    };
    rule.media = {
        use: {
            urlLoader: {
                options: Object.assign({ name: `${staticDirectory}/media/[name].[ext]` }, mediaUrlLoaderOption)
            }
        }
    };
    rule.font = {
        use: {
            urlLoader: {
                options: Object.assign({ name: `${staticDirectory}/fonts/[name].[ext]` }, fontUrlLoaderOption)
            }
        }
    };
    rule.image = {
        use: {
            urlLoader: {
                options: Object.assign({ name: `${staticDirectory}/images/[name].[ext]` }, imageUrlLoaderOption)
            }
        }
    };
    rule.sass = {
        test: /\.(css|scss|sass)(\?.*)?$/,
        use: [lastCssLoader, cssLoader, postcssLoader, resolveUrlLoader, sassLoader]
    };
    rule.less = {
        test: /\.less(\?.*)?$/,
        use: [lastCssLoader, cssLoader, postcssLoader, lessLoader]
    };
    rule.styl = {
        test: /\.styl(\?.*)?$/,
        use: [lastCssLoader, cssLoader, postcssLoader, stylusLoader]
    };
    rule.sassInNodemodules = {
        test: /\.(css|scss|sass)(\?.*)?$/,
        use: [lastCssLoader, cssLoader, sassLoader]
    };
    rule.lessInNodemodules = {
        test: /\.less(\?.*)?$/,
        use: [lastCssLoader, cssLoader, lessLoader]
    };
    rule.stylInNodemodules = {
        test: /\.styl(\?.*)?$/,
        use: [lastCssLoader, cssLoader, stylusLoader]
    };
    const isNodemodule = filename => /\bnode_modules\b/.test(filename);
    if (Array.isArray(esnextModules) && esnextModules.length) {
        const esnextModuleRegs = esnextModules.map(v => new RegExp(`node_modules[\\\\/]${v}`));
        /**
         * isEsnextModule
         *
         * 使用正则匹配判断是否是es模块
         * 规则参考：https://github.com/webpack/webpack/blob/master/lib/RuleSet.js#L413
         */
        const isEsnextModule = filename => esnextModuleRegs.some(reg => reg.test(filename));
        const notTaroModules = filename => isEsnextModule(filename) ? false : isNodemodule(filename);
        /* 通过taro处理 */
        rule.jsx.exclude = [notTaroModules];
        rule.sass.exclude = [notTaroModules];
        rule.less.exclude = [notTaroModules];
        rule.styl.exclude = [notTaroModules];
        rule.sassInNodemodules.include = [notTaroModules];
        rule.lessInNodemodules.include = [notTaroModules];
        rule.stylInNodemodules.include = [notTaroModules];
    }
    else {
        rule.jsx.exclude = [isNodemodule];
        rule.sass.exclude = [isNodemodule];
        rule.less.exclude = [isNodemodule];
        rule.styl.exclude = [isNodemodule];
        rule.sassInNodemodules.include = [isNodemodule];
        rule.lessInNodemodules.include = [isNodemodule];
        rule.stylInNodemodules.include = [isNodemodule];
    }
    return { rule };
};
exports.getModule = getModule;
const getOutput = ([{ outputRoot, publicPath, chunkDirectory }, customOutput]) => {
    return Object.assign({
        path: path.join(_1.appPath, outputRoot),
        filename: 'js/[name].js',
        chunkFilename: `${chunkDirectory}/[name].js`,
        publicPath
    }, customOutput);
};
exports.getOutput = getOutput;
const getDllOutput = ({ outputRoot, dllDirectory }) => {
    return {
        path: path.join(_1.appPath, outputRoot, dllDirectory),
        filename: '[name].dll.js',
        library: '[name]_library'
    };
};
exports.getDllOutput = getDllOutput;
const getDevtool = enableSourceMap => {
    return enableSourceMap ? 'cheap-module-eval-source-map' : 'none';
};
exports.getDevtool = getDevtool;
const getDllReferencePlugins = ({ dllEntry, outputRoot, dllDirectory }) => {
    return fp_1.pipe(fp_1.toPairs, fp_1.map(([key]) => {
        return [`dll${key}`, getDllReferencePlugin(outputRoot, dllDirectory, key)];
    }), fp_1.fromPairs)(dllEntry);
};
exports.getDllReferencePlugins = getDllReferencePlugins;
