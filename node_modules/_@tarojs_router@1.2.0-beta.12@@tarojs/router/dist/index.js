'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Taro = require('@tarojs/taro-h5');
var Taro__default = _interopDefault(Taro);
var Nerv = require('nervjs');
var Nerv__default = _interopDefault(Nerv);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

var warning_1 = warning;

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    warning_1(prompt == null, 'A history supports only one prompt at a time');
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt !== null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          warning_1(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(void 0, arguments);
    };

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};
var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};
var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};
var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};
var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};
var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';

  if (search && search !== '?') {
    path += search.charAt(0) === '?' ? search : "?".concat(search);
  }

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#".concat(hash);
  return path;
};

function createLocation(pathOrLocation, key, currentLocation) {
  var location;

  if (typeof pathOrLocation === 'string') {
    // Two-arg form: push(path, state)
    var tmpLocation = parsePath(pathOrLocation);
    location = Object.assign({}, tmpLocation);
  } else {
    // One-arg form: push(location)
    location = Object.assign({}, pathOrLocation);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.state = {
    key: key
  };
  var params = {};
  var searchString = location.search;

  if (searchString.length > 0) {
    var queryString = searchString.substring(1);
    queryString.split('&').forEach(function (pair) {
      if (pair.indexOf('=') === -1) return;

      var _pair$split = pair.split('='),
          _pair$split2 = _slicedToArray(_pair$split, 2),
          key = _pair$split2[0],
          value = _pair$split2[1];

      params[key] = value;
    });
  }

  location.params = params;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}

var PopStateEvent = 'popstate';
var defaultStoreKey = 'taroRouterStore';
var globalHistory = window.history;

var getHashPath = function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var stateKey = 0;
/**
 * 获取state key
 */

var createKey = function createKey() {
  return String(++stateKey);
};

var getHistoryState = function getHistoryState() {
  try {
    var state = globalHistory.state || {};

    if (typeof state.key !== 'string') {
      state.key = String(stateKey);
    } else {
      stateKey = state.key;
    }

    return state;
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {
      key: String(stateKey)
    };
  }
};

var tryToParseStore = function tryToParseStore(state) {
  var store = {
    key: '0'
  };

  try {
    var storeObj = JSON.parse(localStorage.getItem(defaultStoreKey));

    if (_typeof(storeObj) === 'object' && typeof storeObj.key === 'string') {
      store = storeObj;
    }
  } catch (e) {}

  var isValid = store.key === state.key;
  warning_1(isValid, 'Invalid location store, it is rewrote');

  if (!isValid) {
    store.key = state.key;
  }

  return store;
};
/**
 * 创建对象序列化的函数
 *
 * @param storeObj 需要序列化的对象引用
 */


var createHistorySerializer = function createHistorySerializer(storeObj) {
  var serialize = function serialize() {
    localStorage.setItem(defaultStoreKey, JSON.stringify(storeObj));
  };

  serialize();
  return serialize;
};

var createHistory = function createHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    mode: "hash"
  };
  var transitionManager = createTransitionManager();
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var listenerCount = 0;
  var serialize;

  var getDOMLocation = function getDOMLocation(historyState) {
    var key = historyState.key;
    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = props.mode === "hash" ? addLeadingSlash(getHashPath()) : pathname + search + hash;
    warning_1(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, key);
  };

  var initState = getHistoryState();
  var initialLocation = getDOMLocation(initState);
  var lastLocation = initialLocation;
  var store = tryToParseStore(initState);
  serialize = createHistorySerializer(store);
  globalHistory.replaceState(initialLocation.state, '');
  var createHref = props.mode === "hash" ? function (location) {
    return '#' + addLeadingSlash(basename + createPath(location));
  } : function (location) {
    return basename + createPath(location);
  };

  var setState = function setState(nextState) {
    Object.assign(history, nextState);
    var fromLocation = Object.assign({}, lastLocation); // 记录最后一个location，浏览器前进后退按钮用

    lastLocation = Object.assign({}, nextState.location);
    stateKey = Number(nextState.location.state.key);
    serialize();
    history.length = globalHistory.length;
    var params = {
      fromLocation: fromLocation,
      toLocation: history.location,
      action: history.action
    };
    Taro__default['eventCenter'].trigger('routerChange', Object.assign({}, params));
    transitionManager.notifyListeners(Object.assign({}, params));
  };

  var push = function push(path) {
    var action = 'PUSH';
    var key = createKey();
    var location = createLocation(path, key, history.location);
    var href = createHref(location);
    globalHistory.pushState({
      key: key
    }, '', href);
    store.key = key;
    setState({
      action: action,
      location: location
    });
  };

  var replace = function replace(path) {
    var action = 'REPLACE';
    var key = store.key;
    var location = createLocation(path, key, history.location);
    var href = createHref(location);
    globalHistory.replaceState({
      key: key
    }, '', href);
    setState({
      action: action,
      location: location
    });
  };

  var go = function go(num) {
    globalHistory.go(num);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var handlePopState = function handlePopState(e) {
    // history.pushState和history.replaceState不会触发这个事件
    // 仅在浏览器前进后退操作、history.go/back/forward调用、hashchange的时候触发
    // 这里的window.location已经是新的了
    var state = e.state;

    if (!state) {
      state = {
        key: createKey()
      };
      globalHistory.replaceState(state, '', '');
    }

    var currentKey = Number(lastLocation.state.key);
    var nextKey = Number(state.key);
    var nextLocation = getDOMLocation(state);
    var action;

    if (nextKey > currentKey) {
      action = 'PUSH';
    } else if (nextKey < currentKey) {
      action = 'POP';
    } else {
      action = 'REPLACE';
    }

    store.key = String(nextKey);
    setState({
      action: action,
      location: nextLocation
    });
  };

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
    }
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var history = {
    action: 'POP',
    block: block,
    createHref: createHref,
    go: go,
    goBack: goBack,
    goForward: goForward,
    length: globalHistory.length,
    listen: listen,
    location: initialLocation,
    push: push,
    replace: replace
  };
  return history;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = process.env.NODE_ENV;

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var invariant_1 = invariant;

var createNavigateTo = function createNavigateTo(history) {
  return function (_ref) {
    var url = _ref.url;
    invariant_1(url, 'navigateTo must be called with a url');

    try {
      if (/^(https?:)\/\//.test(url)) {
        window.location.assign(url);
      }

      history.push(url);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject();
    }
  };
};

var createNavigateBack = function createNavigateBack(history) {
  return function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    try {
      var _opts$delta = opts.delta,
          delta = _opts$delta === void 0 ? 1 : _opts$delta;
      invariant_1(delta >= 0, 'navigateBack must be called with a delta greater than 0');
      history.go(-delta);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject();
    }
  };
};

var createRedirectTo = function createRedirectTo(history) {
  return function (_ref2) {
    var url = _ref2.url;
    invariant_1(url, 'redirectTo must be called with a url');

    if (/^(https?:)\/\//.test(url)) {
      window.location.assign(url);
    }

    try {
      history.replace(url);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject();
    }
  };
};

var tryToCall = function tryToCall(func) {
  var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!func) return;

  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (ctx) {
    return func.apply(ctx, args);
  } else {
    return func.apply(void 0, args);
  }
};

var createWrappedComponent = function createWrappedComponent(component) {
  var WrappedComponent =
  /*#__PURE__*/
  function (_component) {
    _inherits(WrappedComponent, _component);

    function WrappedComponent() {
      _classCallCheck(this, WrappedComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(WrappedComponent).apply(this, arguments));
    }

    _createClass(WrappedComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var ctx = this.wrappedInstance || this;
        var originalComponentDidShow = ctx.componentDidShow;

        var superComponentDidMount = _get(_getPrototypeOf(WrappedComponent.prototype), "componentDidMount", this);

        var config = ctx['config'] || {};
        var navigationBarTitleText = config.navigationBarTitleText;

        var newComponentDidShow = function newComponentDidShow() {
          tryToCall(originalComponentDidShow, ctx);

          if (navigationBarTitleText) {
            document.title = navigationBarTitleText;
          }
        };

        ctx.componentDidShow = newComponentDidShow;
        tryToCall(superComponentDidMount, this);

        if (this.wrappedInstance) {
          var originalComponentDidMount = ctx.componentDidMount;

          if (!this.wrappedInstance['__cdm_modified']) {
            this.wrappedInstance['__cdm_modified'] = true;

            this.wrappedInstance.componentDidMount = function () {
              tryToCall(originalComponentDidMount, ctx);
              tryToCall(newComponentDidShow, ctx);
            };
          }

          tryToCall(superComponentDidMount, this);
        } else {
          tryToCall(newComponentDidShow, ctx);
        }
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nProps, nContext) {
        var superComponentWillReceiveProps = _get(_getPrototypeOf(WrappedComponent.prototype), "componentWillReceiveProps", this);

        var nextMatched = nProps.__router.matched;
        var lastMatched = this.props.__router.matched;
        var ctx = this.wrappedInstance || this;
        var componentDidShow = ctx.componentDidShow;
        var componentDidHide = ctx.componentDidHide;

        if (nextMatched || lastMatched) {
          tryToCall(superComponentWillReceiveProps, this, nProps, nContext);
        }

        if (nextMatched === lastMatched) return;

        if (this.wrappedInstance) {
          var componentWillReceiveProps = this.wrappedInstance.componentWillReceiveProps;

          if (!this.wrappedInstance['__cwrp_modified']) {
            this.wrappedInstance['__cwrp_modified'] = true;

            this.wrappedInstance.componentWillReceiveProps = function (nextProps, nextContext) {
              tryToCall(componentWillReceiveProps, ctx, nextProps, nextContext);

              if (nextProps.__router.matched) {
                tryToCall(componentDidShow, ctx);
              } else {
                tryToCall(componentDidHide, ctx);
              }
            };
          }
        } else {
          if (nextMatched === true) {
            tryToCall(componentDidShow, ctx);
          } else {
            tryToCall(componentDidHide, ctx);
          }
        }
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nProps, nState) {
        var nextMatched = nProps.__router.matched;
        var lastMatched = this.props.__router.matched;

        var superShouldComponentUpdate = _get(_getPrototypeOf(WrappedComponent.prototype), "shouldComponentUpdate", this);
        /* 后台页面不刷新 */


        if (!nextMatched && !lastMatched) return false;
        return tryToCall(superShouldComponentUpdate, this, nProps, nState);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var ctx = this.wrappedInstance || this;
        var componentDidHide = ctx.componentDidHide;

        var superComponentWillUnmount = _get(_getPrototypeOf(WrappedComponent.prototype), "componentWillUnmount", this);

        tryToCall(superComponentWillUnmount, this);

        if (this.wrappedInstance) {
          /* for redux */
          var componentWillUnmount = ctx.componentWillUnmount;

          if (!this.wrappedInstance['__cwun_modified']) {
            this.wrappedInstance['__cwun_modified'] = true;

            this.wrappedInstance.componentWillUnmount = function () {
              tryToCall(componentWillUnmount, ctx);
              tryToCall(componentDidHide, ctx);
            };
          }
        } else {
          tryToCall(componentDidHide, ctx);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var router = this.context.router;
        return Nerv__default.createElement("div", {
          className: 'taro_page',
          style: {
            display: router.matched ? 'block' : 'none'
          }
        }, _get(_getPrototypeOf(WrappedComponent.prototype), "render", this).call(this));
      }
    }]);

    return WrappedComponent;
  }(component);

  WrappedComponent.contextTypes = {
    router: Nerv.PropTypes.object,
    store: Nerv.PropTypes.object
  };
  return WrappedComponent;
};

var Route =
/*#__PURE__*/
function (_Component) {
  _inherits(Route, _Component);

  function Route() {
    var _this;

    _classCallCheck(this, Route);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Route).apply(this, arguments));
    _this.state = {
      matched: _this.computeMatch(_this.context.router)
    };

    _this.getRef = function (ref) {
      _this.props.collectComponent(ref, _this.props.k);
    };

    return _this;
  }

  _createClass(Route, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        router: Object.assign({}, this.context.router, {
          matched: this.state.matched
        })
      };
    }
  }, {
    key: "computeMatch",
    value: function computeMatch(router) {
      var pathname = router.location.pathname;
      var key = router.location.state.key;
      var isIndex = this.props.isIndex;
      if (isIndex && pathname === '/') return true;
      return key === this.props.key;
    }
  }, {
    key: "updateComponent",
    value: function updateComponent() {
      var _this2 = this;

      this.props.componentLoader().then(function (_ref) {
        var component = _ref.default;
        var WrappedComponent = createWrappedComponent(component);
        _this2.wrappedComponent = WrappedComponent;

        _this2.forceUpdate();
      });
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.updateComponent();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nProps, nContext) {
      var _this3 = this;

      this.setState(function () {
        if (_this3.props.componentLoader !== nProps.ComponentLoader) _this3.updateComponent();
        return {
          matched: _this3.computeMatch(nContext.router)
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.wrappedComponent) return null;
      var router = this.context.router;
      var matched = this.state.matched;
      var WrappedComponent = this.wrappedComponent;
      return Nerv__default.createElement(WrappedComponent, Object.assign({}, {
        __router: {
          matched: matched,
          location: router.location
        },
        ref: this.getRef
      }));
    }
  }]);

  return Route;
}(Taro.Component);

Route.contextTypes = {
  router: Nerv.PropTypes.object.isRequired
};
Route.childContextTypes = {
  router: Nerv.PropTypes.object,
  store: Nerv.PropTypes.object
};

var Router =
/*#__PURE__*/
function (_Component) {
  _inherits(Router, _Component);

  function Router() {
    var _this;

    _classCallCheck(this, Router);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Router).apply(this, arguments));
    _this.currentPages = [];
    _this.state = {
      location: _this.props.history.location,
      routeStack: []
    };

    _this.collectComponent = function (comp, k) {
      _this.currentPages[k] = comp;
    };

    return _this;
  }

  _createClass(Router, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        router: {
          location: this.state.location
        }
      };
    }
  }, {
    key: "mountApis",
    value: function mountApis() {
      var _this2 = this;

      // 挂载Apis
      Taro__default.navigateTo = createNavigateTo(this.props.history);
      Taro__default.navigateBack = createNavigateBack(this.props.history);
      Taro__default.redirectTo = createRedirectTo(this.props.history);

      Taro__default.getCurrentPages = function () {
        return _this2.currentPages;
      };
    }
  }, {
    key: "computeMatch",
    value: function computeMatch(location) {
      // 找出匹配的路由组件
      var pathname = location.pathname;
      var matchedRoute = this.props.routes.find(function (_ref) {
        var path = _ref.path,
            isIndex = _ref.isIndex;
        if (isIndex && pathname === '/') return true;
        return pathname === path;
      });
      invariant_1(matchedRoute, "Can not find proper registered route for '".concat(pathname, "'"));
      return matchedRoute;
    }
  }, {
    key: "push",
    value: function push(toLocation) {
      var routeStack = _toConsumableArray(this.state.routeStack);

      var matchedRoute = this.computeMatch(toLocation);
      routeStack.push(Object.assign({}, matchedRoute, {
        key: toLocation.state.key
      }));
      this.setState({
        routeStack: routeStack,
        location: toLocation
      });
    }
  }, {
    key: "pop",
    value: function pop(toLocation, fromLocation) {
      var routeStack = _toConsumableArray(this.state.routeStack);

      var fromKey = Number(fromLocation.state.key);
      var toKey = Number(toLocation.state.key);
      var delta = toKey - fromKey;
      routeStack.splice(delta);

      if (routeStack.length === 0) {
        // 不存在历史栈, 需要重新构造
        var matchedRoute = this.computeMatch(toLocation);
        routeStack = [Object.assign({}, matchedRoute, {
          key: toLocation.state.key
        })];
      }

      this.setState({
        routeStack: routeStack,
        location: toLocation
      });
    }
  }, {
    key: "replace",
    value: function replace(toLocation) {
      var routeStack = _toConsumableArray(this.state.routeStack);

      var matchedRoute = this.computeMatch(toLocation);
      routeStack.splice(-1, 1, Object.assign({}, matchedRoute, {
        key: toLocation.state.key
      }));
      this.setState({
        routeStack: routeStack,
        location: toLocation
      });
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      var _this3 = this;

      var history = this.props.history;
      this.mountApis();
      this.unlisten = history.listen(function (_ref2) {
        var fromLocation = _ref2.fromLocation,
            toLocation = _ref2.toLocation,
            action = _ref2.action;

        if (action === "PUSH") {
          _this3.push(toLocation);
        } else if (action === "POP") {
          _this3.pop(toLocation, fromLocation);
        } else {
          _this3.replace(toLocation);
        }

        _this3.lastLocation = history.location;

        _this3.setState({
          location: history.location
        });
      });
      this.lastLocation = history.location;
      this.push(this.lastLocation);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unlisten();
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var router = this;
      router.currentPages.length = this.state.routeStack.length;
      return Nerv__default.createElement("div", {
        className: "taro_router"
      }, this.state.routeStack.map(function (_ref3, k) {
        var path = _ref3.path,
            componentLoader = _ref3.componentLoader,
            isIndex = _ref3.isIndex,
            key = _ref3.key;
        return Nerv__default.createElement(Route, {
          path: path,
          componentLoader: componentLoader,
          isIndex: isIndex,
          key: key,
          k: k,
          collectComponent: _this4.collectComponent
        });
      }));
    }
  }]);

  return Router;
}(Taro.Component);

Router.childContextTypes = {
  router: Nerv.PropTypes.object.isRequired
};

var Router$1 =
/*#__PURE__*/
function (_Component) {
  _inherits(Router$$1, _Component);

  function Router$$1() {
    _classCallCheck(this, Router$$1);

    return _possibleConstructorReturn(this, _getPrototypeOf(Router$$1).apply(this, arguments));
  }

  _createClass(Router$$1, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      var mode = this.props.mode;
      this.history = createHistory({
        mode: mode,
        basename: this.props.publicPath
      });
    }
  }, {
    key: "render",
    value: function render() {
      return Nerv__default.createElement(Router, {
        history: this.history,
        routes: this.props.routes
      });
    }
  }]);

  return Router$$1;
}(Taro.Component);

exports.Router = Router$1;
